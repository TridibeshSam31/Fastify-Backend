ğŸï¸ 1. Fastifyâ€™s Core Philosophy

Fastify is built around:

Performance â†’ Itâ€™s one of the fastest Node.js frameworks.

Schema-first â†’ Strong focus on request/response validation using JSON Schema.

Plugins â†’ Encapsulation and reusability.

Async-first â†’ Fully supports async/await out of the box.

Whereas Express feels like a â€œglorified router,â€ Fastify feels like a â€œframework with guardrails.â€



ğŸ“‚ 2. File Uploads in Fastify

In Express youâ€™d typically use multer (loads the entire file in memory, then saves).
In Fastify, uploads are handled via streams from the fastify-multipart plugin.

Why streams?

You donâ€™t block memory with large files.

Data flows chunk by chunk, so itâ€™s efficient.

Key Concepts:

request.parts() â†’ Async iterator that yields each part of a multipart request.

part.file â†’ The actual stream if itâ€™s a file.

part.value â†’ Field value if itâ€™s plain text.

You can mix text + file in one request.


what are parts that we used in thumbnail.js ????

1. What is parts() in Fastify?

request.parts() comes from the @fastify/multipart
 plugin.

It returns an async iterator that lets you loop over all parts of a multipart request.

A multipart request can contain:

Files (binary data streams)

Fields (regular text input like name, email, etc.)

Or mixed (fields + files together)


Think of parts() as:
ğŸ‘‰ â€œGive me every chunk of the multipart request one by one.â€

2. What does each part look like?
Each part is an object with different properties depending on whether itâ€™s a file or a field
eg if its a file
{
  type: 'file',
  fieldname: 'thumbnail',   // name of the field in the form
  filename: 'cat.png',      // original filename
  encoding: '7bit',
  mimetype: 'image/png',
  file: ReadableStream      // the actual file data stream
}
If itâ€™s a field:
{
  type: 'field',
  fieldname: 'videoName',
  value: 'My Travel Vlog',
  fieldnameTruncated: false,
  valueTruncated: false
}
Notice the difference:

File â†’ has a .file property (stream).in the 1st example we use filename as cat.png where as in the second example we just used filename as a string
Field â†’ has a .value property (string).

3. How do we use it?
Since parts() is an async iterator, you use for await ... of:
const parts = request.parts();

for await (const part of parts) {
  if (part.file) {
    // It's a file â†’ save it
    const saveTo = path.join("uploads", Date.now() + "-" + part.filename);
    await pipelineAsync(part.file, fs.createWriteStream(saveTo));
  } else {
    // It's a field â†’ collect it
    fields[part.fieldname] = part.value;
  }
}
This lets you handle multiple files and fields in a single request.


Why not request.body?
In a multipart/form-data request, request.body doesnâ€™t contain the file streams.
Files come as streams to avoid loading the whole thing into memory (important for large files).
Thatâ€™s why Fastify uses request.parts() instead of giving you everything in body.

Big Picture (Compared to Express/Multer)
Express + Multer: Parses the whole request, buffers the file, gives you req.file or req.files.
Fastify + Multipart (parts()): Streams each part as it arrives, so you can process files without buffering everything.
This makes Fastify more memory-efficient and faster for large file uploads.

